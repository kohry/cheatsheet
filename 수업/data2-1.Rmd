---
title: "data 2-1"
output:
  word_document: default
  html_document: default
---

```{r}
library(MASS)
library(car)
```

# 분산분석

- 일표본 : 모집단이 하나
- 이표본 : 모집단이 따로 두개가 있어서 유사한지 아닌지

세개의 분산을 이용해서 세개의 평균을 이용하겠다. 

전체평균을 구함.

<<* 분산분석에 대한 그래프.>>


TUkey라는 방법으로는 집단들끼리 차이검정 가능.

완전한 데이터 셋인지 검증하는 함수가 있는데 complete.cases. NA데이터는 떨궈준다.

```{r}
head(complete.cases(survey))
survey1 = na.omit(survey)
```

관측값 ~ 그룹변수 (factor, + 그룹변수연결)

```{r}
m1 = aov(Pulse ~ Exer + Smoke, survey1)
summary(m1)
```

Residuals, 집단내 차이. Exer sum sq는 차이에 제곱. mean sq는 자유도로 나눈거임. F값은 그룹간 그룹내 이렇게. 
576 / 128 = 4.5 , 108/128 = 0.842 이게F값.

조인된 경우도 할수있음. 넣고빼고 할수있다능? 뭔개소리야

```{r}
m2 = aov(Pulse ~ Exer + Smoke + Exer:Smoke, survey1)
summary(m2)
```

아래와 같이 표현하면, 각각의 조인된 경우도 볼수 있다. ^3 은 더 조인을 볼수있음.
교호작용을 더 살펴볼수 있음.

```{r}
m3 = aov(Pulse ~ (Exer + Smoke + M.I)^2, survey1)
summary(m3)
```

x : model, which : 그룹변수 

```{r}
TukeyHSD(m1, 'Exer')
```

다중비교, 상호분석이라는 용어로 지칭함. SPSS같은건 상호분석으로 되어있다. 사후분석이라 부르기도 함. 다중비교.
car패키지에 튜키가 있음.

그룹상호작용에 의해 예상못했던 효과 나오는게 있음. 그게 바로 콜론찍어서 나올수있는 거시기임.
집단들끼리 차이검정을 해본거임.

## 함수관계식

```{r}
plot(cars)
```

이걸보면, 상관도가 보인다. 양의 상관관계가 있어보인다.
관계성이 안보이면 제곱을 한다든지, 차원을 줄이든지 할수 있다. 
관계식이 있어야 가능.
수치로 보도록 하는게 공분산과 상관계수.

각각의 값의 차이의 비교값을 공분산이라고 부름. 공분산은 단위가 너무 큼. 동일한 잣대로 좋은건지 나쁜건지 이런 규격이 없다. 
기존에 있던 데이터를 동일한 규격을 맞추기 위해 바꾼것처럼, 단위를 맞춘게 상관계수?
공분산을 표준화시킨게 상관계수임.

던칸은 tukey대신 써볼수있다능. 더빈왓슷(자기상관)
분산확대인자 뭐 이런것도 있고. 레벤테스트 .. 멀티베리어블 분산함수. 
wilcox, 등. 등분산인지 아닌지 확인도 가능하다.

등분산, 이분산이 다르다. 보정하는 항목이 다르다. 해석을 할때는 체킹을 좀 해놔야함.

# 공분산

```{r}
cov(cars)
```

수치가 좋은지 안좋은지 알수가 없다.

```{r}
cor(cars)
```

0.2이상은 만들수있지만 썩좋은게 아니고, 0.6정도되면 꽤 괜찮은 거 알아낼수있음. 0.8이상은 그냥 완전 상관관계임.

```{r}
cor(iris[,1:4])
```

0과 0.1사이는 굳이 할 필요는 없다. 그냥 0에 가깝다능. 로그를 취한다든가 해볼필요는 있음. 
y = a + bx 라는 식에서 y식이 주어진게 라벨링 데이터. y에 어떤 영향을 미치는지 해봐야함. weight라고도 하고 coefficient라고도 하고,
얼마나 영향력을 미치는지에 대한 가중치와 연관이 있다. 
제곱으로 나타내기도 하고 한개도 아니고 두개. x여러개가 있는게 다중선형회귀에 일차식. 제곱으로 넣고 2차항 이상은 다항회귀라고 함.

신경망도 마찬가지임. weight값을 찾고 어떠한 값을 넘겨주고 이런 변환함수를 취하게 된다. 회귀에 쓰는 기법들이 신경망으로 감. 
결국에는 회귀가 확장이 된거임. 

# 단순 선형회귀

y = 반응변수, 종속변수
x = 설명변수, 독립변수, 

~ .
~ 1
~ 변수
~ -변수명 (이 변수를 제외하고 다 넣어라)
~ (변수1 + 변수2)^2
~ 변수1 + 변수2 + 변수 1 : 변수 2

```{r}
model <- lm(dist ~ speed, cars)
anova(model)
summary(model)
```

ANOVA를 먼저 체크하자!. 
F통계량이 아노바를 쳐서 나오는거임. 
엡실론은 다양하게 값이 나올수있는 변수가 숨어져있다. 이런게 하나하나 정규분포를 보이고 있다. 이런걸 등분산, 다른게 있습니다. 이분산.
단순선형회귀는 잔차에 대한 건 정규분포. 첨자가 전혀 들어가있지 않은데, 그냥 흩어진 정도가 각각 동일하다는 말임. 
그런가정 하에서 하는게 단순선형회귀임.
독립이고 정규분포라는거. 가정이 맞는지 안맞는지 점검을 하여야 함.

분산분석 = 각각의 전체에 대한 최소제곱법. 회귀식은 각각 회귀식이 존재하는지 안하는지 확인을 해보고 고고싱해야함.
섦명양이많으면 회귀식이 존재한다는것. 저 식의 평가에 따라서.
기각이 되면 회귀식이 존재한다는것. 이게바로 F통계량 무조건 이것부터 봐야함.

1) 회귀식의 존재유무 판단. 
2) 상수항이 존재하는지 개별체킹 

알 스퀘어가 변동량을 사각형으로 표현해을때, 전체 변동량중에 회귀식에 의해 표현되어 있는 변동량이 알 스퀘어.
0.6이상은 나와야하는다는것이죠. 설명력은 떨어질수도 있음.

모형이 존재하는지 안하는지 그것부터 체킹해야함. 위는 65%정도가 설명되어진다는거임. 인터셉트는 상수항. 모평균에 대해 검증하게 됨. T value에서. 

귀무가설은 모든게 계수가 0이다라는 가설하에서 그렇게. t분포'
각각에 대한 표준오차가 구해져있음. ste.error. 

1) 모형전체의 유무를 체크하고 
2) 알파베타 
3) 가정을 만족하는지

```{r}
plot(model)
```

총 네개의 plot이 그려지게 되는데, 

```{r}
plot(model, which = c(1))
```

1) Residual vs Fitted
추정값은 이식, 엡실론이 없는 알파. 에이더하기 비엑스면 에이와 비를 ..
xi에 따라 항상 같은게 나올거임. 이게 fitted value. 
무작위로 떨어져있어야함. 독립이 되서 그냥 보이게끔. 관계성이 없어야 한다. 제로를 기준으로 위아래로 치우치지 않았으니 오케이. 한쪽의 방향성은 없다. 숫자들이 찍히게 되는 부분은 뭔가 잔차가 큰것들임. 심한것들은 이상치인지 아닌지 레벤 점검해볼수있는 차트가 나타나게 됨. 빨간색은 기준선으로 그려놓음. 점선과 일치되게끔. 빨간색이 경향성. 중심점을 그려놨다.

```{r}
model$coefficients
```

```{r}
plot(model, which = c(2))
```

2) QQ
분위수로 나열해놨음. 이론적인거랑 실제적인 값들이 일치하면 대각선을 일치하게 됨. 대각선에 가까울수록 선형.. 정규분포를 띈다라고 할수있음. 정규성을 만족하는지 안하는지 확인 데이터라고 볼수있음. 지금의 이상치들은 좀 벗어나는게 있기는 있다. 이상치를 조정하면 차트의 모양도 달라진다.

잔차가 고르게 흩어져있다는거임. 잔차가 어떻게 흩어져있는지, QQ를 통해서 정규분포인지 아닌지 확인할수있다. 잔차에 대해서!! QQ는 잔차에 대해서 정규분포를 띄고있는지 확인할수있음. 

```{r}
plot(model, which = c(3))
```

1)하고 같은데 루트를 씌워서 단위들이 똑같은거임

```{r}
plot(model, which = c(5))
```


이상치를 알아내주는 거시기. 중심으로부터 흩어져 있는 거리만큼 그린거임. 빨강 점선을 보면 이상치를 벗어나는 데드라인임. 이상치가 존재하면 영향을 받음. 이상치라고 판명이 되는순간 그 데이터를 제외하고 다시 데이터를 돌려야함. 이상치유무를 시각적으로 판단할수 있음. 이상치 판단 패키지가 다섯개정도 있음. boxplot을 그리는 방식인데, 중앙값 퀀타일 QR. 박스를 그리는데 중앙값. Median. 각각 1/4 범위 3/4 범위. IQR은 1.5배? 중앙값을 기준으로 IQR+1.5 이 범위를 벗어나는 점포인트를 찍히면 이상치로 판단함.
1.5배면 이 안에 데이터가 들어간다. 벗어나는건 이상치를 벗어난다. 박스플롯으로 인지가능. 

cook's distance 각각 데이터 중심 구하고 거리를 구하고 구해서 위치에 따라 그리는데 데드라인을 보고 레버리지 라고 함. 아웃라이어 테스트라는 거시기가 있음. 아웃라이어입니다. 수치를 메기는게 있음. LOF도 거리를 구하는 공식인데, 지엽적인 아웃라이어 가능성을 수치로 보아라. 상위 몇개로 할것인지 아웃라이어 처리하겠습니다. 잘라내는 방식이다? 

# 아웃라이어 만들기

```{r}
car2 = cars
car2[49,2] = 200 # Originally 120, changed to 200.
boxplot(car2$dist)
```

이 데이터를 가지고 lm을 한번 해본다.

```{r}
model2 <- lm(dist~speed, car2)
plot(model2, which = 4:6)
```
4) 중심으로부터 거리들을 보는거임. 49번은 너무 높음. 
5) 49번은 중심으로부터 많이 벗어나고있음

# 아웃라이어 패키지를 이용한 아웃라이어 확인

```{r}
library(outliers)
o <- outlier(car2)
o
```

바로 아웃라이어를 뽑아낼수 있다. 

car패키지에서도 outlier.test를 써볼수있다. 그래서 인덱스를 뽑아내서 아웃라이어 거시기 할수있음

```{r}
o2 <- outlierTest(model2)
o2
# car2[-49,]
```

각각에 대해서 p-value값으로.. 0.05보다 작으면 아웃라이어. 귀무가설은 아니다가 그거심. 앞에 49가 행번호가 보임.


#swiss 데이터 분석

```{r}
str(swiss)
```

```{r}
swiss_model <- lm (Fertility ~ ., data = swiss)
anova(swiss_model)
summary(swiss_model)
```

개별적으로 유의한걸 확인한다. Examination을 제외한 놈들은 0.05보다 작으므로 유의수준 하에서 유의미하다. 
f값은 19.76 p-value값이 0.05보다 작다. 유의수준 5프로 하에서 0.05보다 작으므로 유의하다. 
p-value가 낮을수도 있는데 결정계수가 낮을수도 있다.

R-square를 보면, 0.7067 을 보면 된다. 이값은 충분히 설명력이 있다. adjust는 필요없는 변수들 빼고 최적화된 변수 함수식을 찾을건데 추가될때 adjust가 어떻게 되는지 알수 있다. 

잔차를 보면

```{r}
plot(swiss_model)
```

1) 등분산성 만족함
2) qq 잘 위치하고 있는지. 아주 정상적으로 위치하고 있다. 


바로 step을 하는게 나을수도 있다.
선형으로 안나오는 경우가 있는데, 비선형으로 해결하도록 그런 모형 한번 해볼수 있다.

# 변수선택법
다중공성선 문제라고 해서, 변수들간에 함수관계식이 존재하면 안됨. y=x관계. 얼마나 영향을 미치는지.
독립변수간에 뭔가 존재하면 안됨. step에는 다중공선성 제거하는거에 포함되어있기때문에.. 이걸쓰면됨

분산확대인자, 분산팽창인자 입력변수간에 어떻게 되느냐에 따라 선택을 하게됨.VIF 분산확대인자. 변수중에 이변수와 이변수가에 변수를 찾아주는 역할. spss는 별도로 처리하게 되는데 R은 지가 알아서 함.

step(모형, direction = "forward", "backward", "both", scope = forward인 경우 최대 추가할 변수 목록)

일반적으로 both를 많이 씀.

```{r}
stepped_model <- step(lm(Fertility ~ 1, data = swiss), direction = "forward", scope = "~Agriculture+Examination+Education+Catholic+Infant.Mortality")
summary(stepped_model)
```

최종 예측은 아래와 같이 한다. 

```{r}
predict(model, newdata = data.frame(speed=c(5,10)))
```


```{r}
both_model <- step(swiss_model, direction = "both")
summary(both_model)
```

AIC값이 더 작아지지 않을때까지 계속한다. 

